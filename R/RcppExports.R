# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

resampleSubOptimal <- function(w, N) {
    .Call('_dpf_resampleSubOptimal', PACKAGE = 'dpf', w, N)
}

resampleOptimal <- function(w, N) {
    .Call('_dpf_resampleOptimal', PACKAGE = 'dpf', w, N)
}

kf1stepR <- function(a0, P0, dt, ct, Tt, Zt, HHt, GGt, yt) {
    .Call('_dpf_kf1stepR', PACKAGE = 'dpf', a0, P0, dt, ct, Tt, Zt, HHt, GGt, yt)
}

dpf <- function(currentStates, w, N, transProbs, a0, P0, dt, ct, Tt, Zt, HHt, GGt, yt) {
    .Call('_dpf_dpf', PACKAGE = 'dpf', currentStates, w, N, transProbs, a0, P0, dt, ct, Tt, Zt, HHt, GGt, yt)
}

#' Evaluate the likelihood given parameters and discrete states
#' 
#' @param pmats a list of parameter matrices for the kalman filter. This can either be the output of yupengMats, or a list with the same names as the output of yupengMats.
#' @param path vector giving the desired path for hidden discrete states
#' @param y observations, each time point in a column
#' 
#' @return the negative log-likelihood
#' 
#' @export 
getloglike <- function(pmats, path, y) {
    .Call('_dpf_getloglike', PACKAGE = 'dpf', pmats, path, y)
}

#' Create parameter matrices as in Gu (2017)
#' 
#' @param lt durations between successive notes in the score
#' @param sig2eps variance of the observation noise
#' @param mus vector of 3 mean parameters (\eqn{\mu, \tau, and \varphi})
#' @param sig2eta vector of 3 state variance parameters (\eqn{\sigma_3^2, \sigma_2^2,and \sigma_4^2})
#' @param transprobs vector of 4 transition probabilities (\eqn{p_1, p_2, p_3, p_4})
#' 
#' @return List with components as appropriate for Kalman filtering or Beam Search. These include: \describe{
#' \item{a0}{a pxd matrix of the initial means of the hidden state. The j'th column corresponds to the initial mean when starting in the j'th discrete state.}
#' \item{P0}{a (p^2)xd matrix of the initial covariances of the hidden state. The j'th column corresponds to the initial covariances stored columnwise when starting in the j'th discrete state.}
#' \item{dt}{a pxdxn cube of state intercepts. The j'th column of the i'th slice corresponds to the intercept specified by the j'th discrete state at time i.}
#' \item{ct}{a kxdx1 cube of observation intercepts. The j'th column corresponds to the intercept specified by the j'th discrete state.}
#' \item{Tt}{a (p^2)xdxn cube of state slopes. The j'th column of the i'th slice corresponds to the slope matrix stored columnwise of the j'th discrete state at time i.}
#' \item{Zt}{a pkxdx1 cube of obvervation slopes. The j'th column corresponds to the slope matrix stored columnwise of the j'th discrete state.}
#' \item{HHt}{a (p^2)xdxn cube of state covariances. The j'th column of the i'th slice corresponds to the covariance matrix stored columnwise of the j'th discrete state at time i.}
#' \item{GGt}{a (k^2)xdx1 cube of observation covariances. The j'th column corresponds to the covariance matrix stored columnwise of the j'th discrete state.}
#' \item{transMat}{a dxd matrix of transition probabilities for the discrete states}
#' }
#' 
#' @export    
yupengMats <- function(lt, sig2eps, mus, sig2eta, transprobs, initialMean, initialVariance) {
    .Call('_dpf_yupengMats', PACKAGE = 'dpf', lt, sig2eps, mus, sig2eta, transprobs, initialMean, initialVariance)
}

#' Greedy HMM estimation given continuous hidden states
#' 
#' @param a0 a px1 matrix of state prior means
#' @param P0 a pxp state prior covariance matrix
#' @param w0 a vector specifying the prior probability of starting in each of the d discrete states
#' @param dt a pxdxn (or pxdx1 if all n slices are the same) cube of state intercepts. The j'th column of the i'th slice corresponds to the intercept specified by the j'th discrete state at time i.
#' @param ct a kxdxn (or kxdx1 if all n slices are the same) cube of observation intercepts. The j'th column of the i'th slice corresponds to the intercept specified by the j'th discrete state at time i.
#' @param Tt a (p^2)xdxn (or (p^2)xdx1 if all n slices are the same) cube of state slopes. The j'th column of the i'th slice corresponds to the slope matrix stored columnwise of the j'th discrete state at time i.
#' @param Zt a pkxdxn (or pkxdx1 if all n slices are the same) cube of obvervation slopes. The j'th column of the i'th slice corresponds to the slope matrix stored columnwise of the j'th discrete state at time i.
#' @param HHt a (p^2)xdxn (or (p^2)xdx1 if all n slices are the same) cube of state covariances. The j'th column of the i'th slice corresponds to the covariance matrix stored columnwise of the j'th discrete state at time i.
#' @param GGt a (k^2)xdxn (or kxdx1 if all n slices are the same) cube of observation covariances. The j'th column of the i'th slice corresponds to the covariance matrix stored columnwise of the j'th discrete state at time i.
#' @param yt a kxn matrix of obervations
#' @param transProbs a dxd matrix of transition probabilities for the discrete states
#' @param N the maximum particle number
#' 
#' @return List with components "paths", "weights", and "LastStep". "paths" is an Nxn matrix specifying the paths of each particle, "weights" is a vector giving the final sampling weight of each path, and "LastStep" is the timestep computed. "LastStep" will alway equal n unless all of the sampling weights vanish.
#' 
#' @export 
beamSearch <- function(a0, P0, w0, dt, ct, Tt, Zt, HHt, GGt, yt, transProbs, N) {
    .Call('_dpf_beamSearch', PACKAGE = 'dpf', a0, P0, w0, dt, ct, Tt, Zt, HHt, GGt, yt, transProbs, N)
}

#' Estimate continuous states given parameters and discrete hidden states
#' 
#' @param pmats e.g., as output from yupengMats
#' @param path path of discrete hidden states
#' @param y observations
#' 
#' @return List with components from Kalman filter and Smoother
#' 
#' @export 
kalman <- function(pmats, path, y) {
    .Call('_dpf_kalman', PACKAGE = 'dpf', pmats, path, y)
}

