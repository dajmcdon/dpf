# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Fast likelihood evaluation given parameters and discrete states
#' 
#' This function quickly computes the (negative) log likelihood for a possibly
#' time varying state-space model. The goal is to enable ML (or Bayesian) estimation
#' of parameters without extra computational overhead
#' 
#' @param pmats a list of parameter matrices for the kalman filter. 
#' This can either be the output of \code{\link{musicModel}}, or a list with 
#' the same names as the output of \code{\link{musicModel}}. This list must contain
#' the following elements: \code{a0, P0, dt, ct, Tt, Zt, HHt, GGt}. See the details below.
#' @param path vector giving the path for hidden discrete states
#' @param y observations, each time point in a column
#' 
#' @return the negative log-likelihood
#'
#' @details 
#' \describe{
#' \item{a0}{a pxd matrix of the initial means of the hidden state. The j'th column corresponds to the initial mean when starting in the j'th discrete state.}
#' \item{P0}{a (p^2)xd matrix of the initial covariances of the hidden state. The j'th column corresponds to the initial covariances stored columnwise when starting in the j'th discrete state.}
#' \item{dt}{a pxdxn cube of state intercepts. The j'th column of the i'th slice corresponds to the intercept specified by the j'th discrete state at time i.}
#' \item{ct}{a kxdx1 cube of observation intercepts. The j'th column corresponds to the intercept specified by the j'th discrete state.}
#' \item{Tt}{a (p^2)xdxn cube of state slopes. The j'th column of the i'th slice corresponds to the slope matrix stored columnwise of the j'th discrete state at time i.}
#' \item{Zt}{a pkxdx1 cube of obvervation slopes. The j'th column corresponds to the slope matrix stored columnwise of the j'th discrete state.}
#' \item{HHt}{a (p^2)xdxn cube of state covariances. The j'th column of the i'th slice corresponds to the covariance matrix stored columnwise of the j'th discrete state at time i.}
#' \item{GGt}{a (k^2)xdx1 cube of observation covariances. The j'th column corresponds to the covariance matrix stored columnwise of the j'th discrete state.}
#' }
#' 
#' @examples
#' data(tempos)
#' theta = c(426.69980736, 136.33213703, -11.84256691, -34.82234559, 
#'           439.37886221, 1, 1, 0.84916635, 0.04611644, 0.74119571, 
#'           0.43966082, 0.02116317, 0.24513563, 0.17253254)
#' y = matrix(tempos[,'Richter_1976'], 1)
#' lt = diff(c(tempos$note_onset, 61))
#' pmats = musicModel(lt, theta[1], theta[2:4], theta[5:7], theta[8:14], 
#'                   c(132,0), c(400,10)) # prior means and variances on X_1
#' beam = with(pmats, beamSearch(a0, P0, c(1,0,0,0,0,0,0,0,0,0), dt, ct, Tt, Zt,
#'             HHt, GGt, y, transMat, 200))
#' bestpath = with(beam, paths[which.max(weights),])
#' getloglike(pmats, bestpath, y)
#' 
#' @export 
getloglike <- function(pmats, path, y) {
    .Call('_dpf_getloglike', PACKAGE = 'dpf', pmats, path, y)
}

#' Parameter matrices for our music model
#' 
#' This function accepts a number of parameters and creates a list of matrices
#' for Kalman filter evaluation. See the paper for the particular form of the model.
#' 
#' @param lt vector of durations between successive notes in the score
#' @param sig2eps variance of the observation noise
#' @param mus vector of 3 mean parameters (\eqn{\mu, \tau, and \varphi})
#' @param sig2eta vector of 3 state variance parameters (\eqn{\sigma_3^2, \sigma_2^2,and \sigma_4^2})
#' @param transprobs vector of 7 transition probabilities
#' @param initialMean a vector of length 2 giving the prior tempo and the prior acceleration for when state 1 or 3 is the starting state
#' @param initialVariance a vector of length 2 giving the prior variance for the tempo and the prior variance for the acceleration for when state 1 or 3 is the starting state 
#' 
#' @return List with components as appropriate for Kalman filtering or Beam Search. These include: \describe{
#' \item{a0}{a pxd matrix of the initial means of the hidden state. The j'th column corresponds to the initial mean when starting in the j'th discrete state.}
#' \item{P0}{a (p^2)xd matrix of the initial covariances of the hidden state. The j'th column corresponds to the initial covariances stored columnwise when starting in the j'th discrete state.}
#' \item{dt}{a pxdxn cube of state intercepts. The j'th column of the i'th slice corresponds to the intercept specified by the j'th discrete state at time i.}
#' \item{ct}{a kxdx1 cube of observation intercepts. The j'th column corresponds to the intercept specified by the j'th discrete state.}
#' \item{Tt}{a (p^2)xdxn cube of state slopes. The j'th column of the i'th slice corresponds to the slope matrix stored columnwise of the j'th discrete state at time i.}
#' \item{Zt}{a pkxdx1 cube of obvervation slopes. The j'th column corresponds to the slope matrix stored columnwise of the j'th discrete state.}
#' \item{HHt}{a (p^2)xdxn cube of state covariances. The j'th column of the i'th slice corresponds to the covariance matrix stored columnwise of the j'th discrete state at time i.}
#' \item{GGt}{a (k^2)xdx1 cube of observation covariances. The j'th column corresponds to the covariance matrix stored columnwise of the j'th discrete state.}
#' \item{transMat}{a dxd matrix of transition probabilities for the discrete states}
#' }
#' 
#' @examples
#' data(tempos)
#' theta = c(426.69980736, 136.33213703, -11.84256691, -34.82234559, 
#'           439.37886221, 1, 1, 0.84916635, 0.04611644, 0.74119571, 
#'           0.43966082, 0.02116317, 0.24513563, 0.17253254)
#' y = matrix(tempos[,'Richter_1976'], 1)
#' lt = diff(c(tempos$note_onset, 61))
#' pmats = musicModel(lt, theta[1], theta[2:4], theta[5:7], theta[8:14], 
#'                   c(132,0), c(400,10))
#'                   
#' @export    
musicModel <- function(lt, sig2eps, mus, sig2eta, transprobs, initialMean, initialVariance) {
    .Call('_dpf_musicModel', PACKAGE = 'dpf', lt, sig2eps, mus, sig2eta, transprobs, initialMean, initialVariance)
}

#' Greedy HMM estimation given continuous hidden states
#' 
#' This function maintains a "beam" of size \code{N} representing the highest likelihood
#' states up to time \code{t}. For a typical switching state space model, ML evaluation
#' requires computing each of the \code{d^N} possible paths through the discrete
#' state space. Beam Search greedily approximates these computations be propagating
#' the most likely states at each time point.
#' 
#' @param a0 a pxd matrix of state prior means, where the i'th column is the mean for the i'th state
#' @param P0 a (p^2)xd state prior covariance matrix, where the i'th column is the covariance matrix stored columnwise for the i'th state
#' @param w0 a vector specifying the prior probability of starting in each of the d discrete states
#' @param dt a pxdxn (or pxdx1 if all n slices are the same) cube of state intercepts. The j'th column of the i'th slice corresponds to the intercept specified by the j'th discrete state at time i.
#' @param ct a kxdxn (or kxdx1 if all n slices are the same) cube of observation intercepts. The j'th column of the i'th slice corresponds to the intercept specified by the j'th discrete state at time i.
#' @param Tt a (p^2)xdxn (or (p^2)xdx1 if all n slices are the same) cube of state slopes. The j'th column of the i'th slice corresponds to the slope matrix stored columnwise of the j'th discrete state at time i.
#' @param Zt a pkxdxn (or pkxdx1 if all n slices are the same) cube of obvervation slopes. The j'th column of the i'th slice corresponds to the slope matrix stored columnwise of the j'th discrete state at time i.
#' @param HHt a (p^2)xdxn (or (p^2)xdx1 if all n slices are the same) cube of state covariances. The j'th column of the i'th slice corresponds to the covariance matrix stored columnwise of the j'th discrete state at time i.
#' @param GGt a (k^2)xdxn (or kxdx1 if all n slices are the same) cube of observation covariances. The j'th column of the i'th slice corresponds to the covariance matrix stored columnwise of the j'th discrete state at time i.
#' @param yt a kxn matrix of obervations
#' @param transProbs a dxd matrix of transition probabilities for the discrete states
#' @param N the maximum particle number
#' 
#' @return List with components "paths", "weights", and "LastStep". 
#' \describe{
#' \item{"paths"}{is an Nxn matrix specifying the paths of each particle,}
#' \item{"weights"}{is a vector giving the final sampling weight of each path,}
#' \item{"LastStep"}{is the timestep computed. "LastStep" will alway equal n unless all of the sampling weights vanish.}
#' }
#' 
#' @examples
#' data(tempos)
#' theta = c(426.69980736, 136.33213703, -11.84256691, -34.82234559, 
#'           439.37886221, 1, 1, 0.84916635, 0.04611644, 0.74119571, 
#'           0.43966082, 0.02116317, 0.24513563, 0.17253254)
#' y = matrix(tempos[,'Richter_1976'], 1)
#' lt = diff(c(tempos$note_onset, 61))
#' pmats = musicModel(lt, theta[1], theta[2:4], theta[5:7], theta[8:14], 
#'                   c(132,0), c(400,10)) # prior means and variances on X_1
#' beam = with(pmats, beamSearch(a0, P0, c(1,0,0,0,0,0,0,0,0,0), dt, ct, Tt, Zt,
#'             HHt, GGt, y, transMat, 200))
#' 
#' @export 
beamSearch <- function(a0, P0, w0, dt, ct, Tt, Zt, HHt, GGt, yt, transProbs, N) {
    .Call('_dpf_beamSearch', PACKAGE = 'dpf', a0, P0, w0, dt, ct, Tt, Zt, HHt, GGt, yt, transProbs, N)
}

#' Estimate continuous states given parameters and discrete hidden states
#' 
#' Performs Kalman filtering and smoothing for the switching state space model.
#' Also works on any (potentially time varying) state space model.
#' 
#' @param pmats a list with componente \code{a0, P0, dt, ct, Tt, Zt, HHt,} and \code{GGt} 
#' e.g., as output from musicModel. See the details below.
#' @param path path of discrete hidden states
#' @param y observations
#' 
#' @return List with components from Kalman filter and Smoother. See details.
#' 
#' @details
#' 
#' \strong{State space form:}
#' 
#' The following notation is closest to the one of Koopman et al. The state
#' space model is represented by the transition equation and the measurement
#' equation. Let m be the dimension of the state variable, d be the dimension of
#' the observations, and n the number of observations. The transition equation
#' and the measurement equation are given by \deqn{a(t + 1) = d(t) + T(t) a(t) +
#' H(t) \eta(t)} \deqn{y(t) = c(t) + Z(t) a(t) + G(t) \epsilon(t),} where
#' \eqn{\eta(t)} and \eqn{\epsilon(t)} are iid \eqn{N(0, I_m)} and iid \eqn{N(0,
#' I_d)}, respectively, and \eqn{\alpha(t)} denotes the state variable. The
#' parameters admit the following dimensions:
#' 
#' \tabular{lll}{ \eqn{a_t \in R^m}{a[t] in R^m} \tab \eqn{d_t \in R^m}{d[t] in
#' R^m} \tab \eqn{\eta_t \in R^m}{eta[t] in R^m} \cr \eqn{T_t \in R^{m \times
#' m}}{d[t] in R^{m \times m}} \tab \eqn{H_t \in R^{m \times m}}{d[t] in R^{m \times m}}
#' \tab \cr \eqn{y_t \in R^d}{y[t] in R^d} \tab \eqn{c_t \in R^d}{c[t] in R^d}
#' \tab \eqn{\epsilon_t \in R^d}{epsilon[t] in R^d}. \cr \eqn{Z_t \in R^{d
#' \times m}}{Z[t] in R^{d \times m}} \tab \eqn{G_t \in R^{d \times d}}{G[t] in R^{d
#' \times d}} \tab}
#' 
#' Note that \code{kalman} takes as input \code{HHt} and \code{GGt} which
#' corresponds to \eqn{H_t H_t'}{H[t] \%*\% t(H[t])} and \eqn{G_t G_t'}{G[t]
#' \%*\% t(G[t])}.
#' 
#' \strong{Iteration:}
#' 
#' Let \code{i} be the loop variable. The filter iterations are implemented the
#' following way (in case of no NA's): Initialization:\cr \code{if(i == 1)\{}\cr
#' \code{  at[, i] = a0}\cr \code{  Pt[,, i] = P0}\cr \code{\}}
#' 
#' Updating equations:\cr \code{vt[, i] = yt[, i] - ct[, i] - Zt[,,i] \%*\% at[,
#' i]}\cr \code{Ft[,, i] = Zt[,, i] \%*\% Pt[,, i] \%*\% t(Zt[,, i]) + GGt[,,
#' i]}\cr \code{Kt[,, i] = Pt[,, i] \%*\% t(Zt[,, i]) \%*\% solve(Ft[,, i])}\cr
#' \code{att[, i] = at[, i] + Kt[,, i] \%*\% vt[, i]}\cr \code{Ptt[, i] = Pt[,,
#' i] - Pt[,, i] \%*\% t(Zt[,, i]) \%*\% t(Kt[,, i])}
#' 
#' Prediction equations:\cr \code{at[, i + 1] = dt[, i] + Tt[,, i] \%*\% att[,
#' i]}\cr \code{Pt[,, i + 1] = Tt[,, i] \%*\% Ptt[,, i] \%*\% t(Tt[,, i]) +
#' HHt[,, i]}
#' 
#' Next iteration:\cr \code{i <- i + 1}\cr goto \dQuote{Updating equations}.
#' 
#' 
#' \strong{Parameters:}
#' 
#' The parameters can either be constant or deterministic time-varying. Assume
#' the number of observations is \eqn{n} (i.e. \eqn{y = (y_t)_{t = 1, \ldots,
#' n}, y_t = (y_{t1}, \ldots, y_{td})}{y = y[,1:n]}). Then, the parameters admit
#' the following classes and dimensions: \tabular{ll}{ \code{dt} \tab either a
#' \eqn{m \times n}{m * n} (time-varying) or a \eqn{m \times 1}{m * 1}
#' (constant) matrix. \cr \code{Tt} \tab either a \eqn{m \times m \times n}{m *
#' m * n} or a \eqn{m \times m \times 1}{m * m * 1} array. \cr \code{HHt} \tab
#' either a \eqn{m \times m \times n}{m * m * n} or a \eqn{m \times m \times
#' 1}{m * m * 1} array. \cr \code{ct} \tab either a \eqn{d \times n}{d * n} or a
#' \eqn{d \times 1}{d * 1} matrix. \cr \code{Zt} \tab either a \eqn{d \times m
#' \times n}{d * m * n} or a \eqn{d \times m \times 1}{d * m * 1} array. \cr
#' \code{GGt} \tab either a \eqn{d \times d \times n}{d * d * n} or a \eqn{d
#' \times d \times 1}{d * d * 1} array. \cr \code{yt} \tab a \eqn{d \times n}{d
#' * n} matrix. }
#' 
#' \strong{Output:}
#' 
#' The output values are the filter estimates, smoother estimates, 
#' associated forecasts, and the negative log likelihood.
#' 
#' \describe{
#' \item {\code{at}}{One step ahead expectation of the hidden state}
#' \item {\code{Pt}{One step ahead variance of the hidden state}
#' \item {\code{preds}}{One step ahead forecast of the observation}
#' \item {\code{ahat}}{Smoothed state mean (conditional on all data)}
#' \item {\code{att}}{State expectation given information up to time t}
#' \item {\code{Ptt}}{State variance given information up to time t}
#' \item {\code{ests}}{Smoothed forecast (conditionall on all data)}
#' \item {\code{llik}}{log likelihood (not negative)}
#' }
#' 
#' @examples
#' data(tempos)
#' theta = c(426.69980736, 136.33213703, -11.84256691, -34.82234559, 
#'           439.37886221, 1, 1, 0.84916635, 0.04611644, 0.74119571, 
#'           0.43966082, 0.02116317, 0.24513563, 0.17253254)
#' y = matrix(tempos[,'Richter_1976'], 1)
#' lt = diff(c(tempos$note_onset, 61))
#' pmats = musicModel(lt, theta[1], theta[2:4], theta[5:7], theta[8:14], 
#'                   c(132,0), c(400,10)) # prior means and variances on X_1
#' beam = with(pmats, beamSearch(a0, P0, c(1,0,0,0,0,0,0,0,0,0), dt, ct, Tt, Zt,
#'             HHt, GGt, y, transMat, 200))
#' bestpath = with(beam, paths[which.max(weights),])
#' kal = kalman(pmats, bestpath, y)
#' 
#' @export 
kalman <- function(pmats, path, y) {
    .Call('_dpf_kalman', PACKAGE = 'dpf', pmats, path, y)
}

egetloglike <- function(lt, path, y, sig2eps, mus, sig2eta, a0, P0) {
    .Call('_dpf_egetloglike', PACKAGE = 'dpf', lt, path, y, sig2eps, mus, sig2eta, a0, P0)
}

ebeamSearch <- function(lt, w0, sig2eps, mus, sig2eta, a0, P0, y, transProbs, N) {
    .Call('_dpf_ebeamSearch', PACKAGE = 'dpf', lt, w0, sig2eps, mus, sig2eta, a0, P0, y, transProbs, N)
}

ekalman <- function(lt, path, y, sig2eps, mus, sig2eta, a0, P0) {
    .Call('_dpf_ekalman', PACKAGE = 'dpf', lt, path, y, sig2eps, mus, sig2eta, a0, P0)
}

