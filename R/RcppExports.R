# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Move the particles forward in time one step
#' @param currentStates a vector of the current discrete state for each particle
#' @param w a vector of the sampling weights for each particle
#' @param N the maximum particle number
#' @param transProbs a dxd matrix of transition probabilities for the discrete states
#' @param a0 a pxN matrix of the current estimate of the state means. Each column represents a particle
#' @param P0 a (p^2)xN state prior covariance matrix
#' @param dt a pxd matrix of state intercepts. The j'th column corresponds to the intercept specified by the j'th discrete state.
#' @param ct a kxd matrix of observation intercepts. The j'th column corresponds to the intercept specified by the j'th discrete state.
#' @param Tt a (p^2)xd matrix of state slopes. The j'th column corresponds to the slope matrix stored columnwise of the j'th discrete state.
#' @param Zt a pkxd matrix of obvervation slopes. The j'th column corresponds to the slope matrix stored columnwise of the j'th discrete state.
#' @param HHt a (p^2)xd matrix of state covariances. The j'th column corresponds to the covariance matrix stored columnwise of the j'th discrete state.
#' @param GGt a (k^2)xd matrix of observation covariances. The j'th column corresponds to the covariance matrix stored columnwise of the j'th discrete state.
#' @param yt a kxn matrix of obervations
#' 
NULL

resampleSubOptimal <- function(w, N) {
    .Call('_dpf_resampleSubOptimal', PACKAGE = 'dpf', w, N)
}

resampleOptimal <- function(w, N) {
    .Call('_dpf_resampleOptimal', PACKAGE = 'dpf', w, N)
}

kf1stepR <- function(a0, P0, dt, ct, Tt, Zt, HHt, GGt, yt) {
    .Call('_dpf_kf1stepR', PACKAGE = 'dpf', a0, P0, dt, ct, Tt, Zt, HHt, GGt, yt)
}

dpf <- function(currentStates, w, N, transProbs, a0, P0, dt, ct, Tt, Zt, HHt, GGt, yt) {
    .Call('_dpf_dpf', PACKAGE = 'dpf', currentStates, w, N, transProbs, a0, P0, dt, ct, Tt, Zt, HHt, GGt, yt)
}

#' Evaluate the likelihood given parameters and discrete states
#' 
#' @param pmats a list of parameter matrices for the kalman filter. This can either be the output of musicModel, or a list with the same names as the output of musicModel.
#' @param path vector giving the path for hidden discrete states
#' @param y observations, each time point in a column
#' 
#' @return the negative log-likelihood
#' 
#' @export 
getloglike <- function(pmats, path, y) {
    .Call('_dpf_getloglike', PACKAGE = 'dpf', pmats, path, y)
}

#' Create parameter matrices as in Gu (2017)
#' 
#' @param lt durations between successive notes in the score
#' @param sig2eps variance of the observation noise
#' @param mus vector of 3 mean parameters (\eqn{\mu, \tau, and \varphi})
#' @param sig2eta vector of 3 state variance parameters (\eqn{\sigma_3^2, \sigma_2^2,and \sigma_4^2})
#' @param transprobs vector of 7 transition probabilities
#' @param initialMean a vector of length 2 giving the prior tempo and the prior acceleration for when state 3 is the starting state
#' @param initialVariance a vector of length 2 giving the prior variance for the tempo and the prior variance for the acceleration for when state 3 is the starting state 
#' 
#' @return List with components as appropriate for Kalman filtering or Beam Search. These include: \describe{
#' \item{a0}{a pxd matrix of the initial means of the hidden state. The j'th column corresponds to the initial mean when starting in the j'th discrete state.}
#' \item{P0}{a (p^2)xd matrix of the initial covariances of the hidden state. The j'th column corresponds to the initial covariances stored columnwise when starting in the j'th discrete state.}
#' \item{dt}{a pxdxn cube of state intercepts. The j'th column of the i'th slice corresponds to the intercept specified by the j'th discrete state at time i.}
#' \item{ct}{a kxdx1 cube of observation intercepts. The j'th column corresponds to the intercept specified by the j'th discrete state.}
#' \item{Tt}{a (p^2)xdxn cube of state slopes. The j'th column of the i'th slice corresponds to the slope matrix stored columnwise of the j'th discrete state at time i.}
#' \item{Zt}{a pkxdx1 cube of obvervation slopes. The j'th column corresponds to the slope matrix stored columnwise of the j'th discrete state.}
#' \item{HHt}{a (p^2)xdxn cube of state covariances. The j'th column of the i'th slice corresponds to the covariance matrix stored columnwise of the j'th discrete state at time i.}
#' \item{GGt}{a (k^2)xdx1 cube of observation covariances. The j'th column corresponds to the covariance matrix stored columnwise of the j'th discrete state.}
#' \item{transMat}{a dxd matrix of transition probabilities for the discrete states}
#' }
#' 
#' @export    
musicModel <- function(lt, sig2eps, mus, sig2eta, transprobs, initialMean, initialVariance) {
    .Call('_dpf_musicModel', PACKAGE = 'dpf', lt, sig2eps, mus, sig2eta, transprobs, initialMean, initialVariance)
}

#' Greedy HMM estimation given continuous hidden states
#' 
#' @param a0 a pxd matrix of state prior means, where the i'th column is the mean for the i'th state
#' @param P0 a (p^2)xd state prior covariance matrix, where the i'th column is the covariance matrix stored columnwise for the i'th state
#' @param w0 a vector specifying the prior probability of starting in each of the d discrete states
#' @param dt a pxdxn (or pxdx1 if all n slices are the same) cube of state intercepts. The j'th column of the i'th slice corresponds to the intercept specified by the j'th discrete state at time i.
#' @param ct a kxdxn (or kxdx1 if all n slices are the same) cube of observation intercepts. The j'th column of the i'th slice corresponds to the intercept specified by the j'th discrete state at time i.
#' @param Tt a (p^2)xdxn (or (p^2)xdx1 if all n slices are the same) cube of state slopes. The j'th column of the i'th slice corresponds to the slope matrix stored columnwise of the j'th discrete state at time i.
#' @param Zt a pkxdxn (or pkxdx1 if all n slices are the same) cube of obvervation slopes. The j'th column of the i'th slice corresponds to the slope matrix stored columnwise of the j'th discrete state at time i.
#' @param HHt a (p^2)xdxn (or (p^2)xdx1 if all n slices are the same) cube of state covariances. The j'th column of the i'th slice corresponds to the covariance matrix stored columnwise of the j'th discrete state at time i.
#' @param GGt a (k^2)xdxn (or kxdx1 if all n slices are the same) cube of observation covariances. The j'th column of the i'th slice corresponds to the covariance matrix stored columnwise of the j'th discrete state at time i.
#' @param yt a kxn matrix of obervations
#' @param transProbs a dxd matrix of transition probabilities for the discrete states
#' @param N the maximum particle number
#' 
#' @return List with components "paths", "weights", and "LastStep". "paths" is an Nxn matrix specifying the paths of each particle, "weights" is a vector giving the final sampling weight of each path, and "LastStep" is the timestep computed. "LastStep" will alway equal n unless all of the sampling weights vanish.
#' 
#' @export 
beamSearch <- function(a0, P0, w0, dt, ct, Tt, Zt, HHt, GGt, yt, transProbs, N) {
    .Call('_dpf_beamSearch', PACKAGE = 'dpf', a0, P0, w0, dt, ct, Tt, Zt, HHt, GGt, yt, transProbs, N)
}

#' Estimate continuous states given parameters and discrete hidden states
#' 
#' @param pmats e.g., as output from musicModel
#' @param path path of discrete hidden states
#' @param y observations
#' 
#' @return List with components from Kalman filter and Smoother
#' 
#' @export 
kalman <- function(pmats, path, y) {
    .Call('_dpf_kalman', PACKAGE = 'dpf', pmats, path, y)
}

